---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by xindong.
--- DateTime: 2021/2/23 21:47
---

require 'base.promise'
require 'base.co'
require 'base.timer'


env_test_dict.promise_example1 = function()
    -- 测试promise的值的确定性, 被设置值后, 值将永不变化
    local pro = coroutine.promise()

    base.wait(2000, function()
        pro:try_set('123')
    end)

    base.wait(5000, function()
        pro:try_set('456')
    end)

    local ret, err = pro:co_get()
    log_file.info(ret, err)
    assert(ret == '123' and err == nil)

    coroutine.sleep(4000)
    ret, err = pro:co_get()
    log_file.info(ret, err)  -- 123, nil    '456' cannot override '123'
    assert(ret == '123' and err == nil)
end

env_test_dict.promise_example2 = function()
    -- 测试promise的set, 对已经有值了的promise调用set会抛异常, 此时调用try_set则会被忽略
    local pro = coroutine.promise()
    base.wait(1000, function()
        pro:set(1, nil)
    end)
    base.wait(2000, function()
        xpcall(function()
            pro:set(2, nil)
        end, log.info)  -- will log.info err, because pro's value has been set
    end)

    base.wait(2000, function()
        xpcall(function()
            pro:try_set(2, nil)
        end, log.info)  -- nothing
    end)
end

env_test_dict.promise_example3 = function()
    -- 测试promise的值的时序性
    local pro = coroutine.as_promise(function()
        coroutine.sleep(3000)
        return 1
    end)

    base.wait(2000, function()
        local ret, err = pro:get()
        log_file.info('2000', ret, err)
        assert(not ret and err == 'empty')  -- 2秒此时还没有赋值, 所以ret是空的
    end)

    base.wait(4000, function()
        local ret, err = pro:get()
        log_file.info('4000', ret, err)
        assert(ret == 1 and err == nil)  -- 第4秒了, 值已经被设置了. get函数可以反复调用, 具有幂等性
    end)

    local ret, err = pro:co_get()  -- 等待promise结束
    log_file.info('3000', ret, err)
    assert(ret == 1 and err == nil)  -- 已经设置值了
end

env_test_dict.promise_example4 = function()
    -- 测试multi_promise
    local top = 0
    local promise_list = {}
    for i = 1, 10 do
        local pro = coroutine.as_promise(function()
            coroutine.sleep(1000 * i)
            top = top + 1
            assert(top == i)
            log_file.info(i)
            if i == 8 then
                error '8'  -- 第8秒时有个promise失败
            end
            return i
        end)

        table.insert(promise_list, pro)
    end

    local multi_pro_all_finish = coroutine.multi_promise(promise_list, 'all_finish')  -- 等到所有都结束, 即使中间有失败的promise也要等到最后
    local multi_pro_any_finish = coroutine.multi_promise(promise_list, 'any_finish')   -- 任意一个promise结束就结束
    local multi_pro_any_failed = coroutine.multi_promise(promise_list)  -- default is 'any_failed'  -- 等到所有都结束, 但如果中间有失败的promise就立即结束

    coroutine.async(function()
        local ret, err = multi_pro_all_finish:co_get()
        log_file.info(('multi_pro_all_finish finish, i: %s, err: %s'):format(ret, err))  -- 第10秒, 因为要等所有promise都结束
        assert(top == 10)
    end)

    coroutine.async(function()
        local ret, err = multi_pro_any_finish:co_get()
        log_file.info(('multi_pro_any_finish finish, i: %s, err: %s'):format(ret, err))  -- 第一秒, 因为有至少一个promise结束了
        assert(top == 1)
    end)

    coroutine.async(function()
        local ret, err = multi_pro_any_failed:co_get()
        log_file.info(('multi_pro_any_failed, i: %s, err: %s'):format(ret, err))  -- 第八秒, 因为遇到了第一个失败的promise
        assert(top == 8)
    end)

    multi_pro_any_finish:co_get()
    multi_pro_any_failed:co_get()
    multi_pro_all_finish:co_get()
    log_file.info('promise_example4 finish')  -- 第10秒, 因为multi_pro_all_finish最慢, 它需要10秒
    assert(top == 10)
end
