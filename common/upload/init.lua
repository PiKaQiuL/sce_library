---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by xindong.
--- DateTime: 2021/8/11 17:54
---

local account = require 'base.account'  ---@type common_account
local path = require 'base.path'
local io_zip_file = io.zip_file
local co_io_zip_file = coroutine.co_wrap(io_zip_file)
local argv = include '@common.base.argv'

local compress_use_7z = true
if argv.has('compress_use_7z') and argv.get('compress_use_7z') == '0' then  -- 默认使用7z
    compress_use_7z = false
end

---@class upload_package_params
---@field package_name string  必填, 这是地图名
---@field comment string  最好填, 这是数据库里存的注释, 网页上也会有体现
---@field email string  最好填, 出发布结果后, 会给你发个邮件(但愿能发出去...)
---@field upload_data table  不会填就别填了, 真的有需求, 问下 @孙君 到底怎么用
---@field author string    正常情况下这个字段会在服务端被改写, 但有时候有用, 默认是函数里自己给你生成一个(总之非必要最好不填)
---@field zip_path string  与folder二选一, 这是压缩包的路径, 要求是绝对路径, 一定要zip, 别来个7z
---@field folder string    如果懒得打压缩包, 那就传个folder, 由框架自动压缩成zip后再上传, 与zip_path二选一, 要求是绝对路径
---@field path string  例: Res/maps  注意, 起始必然是"Res/" (规定!), 注意开头是大写"R"!!!  比如你要放到Res/foo/package_bar, 那你就填成"Res/foo", 千万不要加上package_bar  默认: "Res/maps"
---@field alias string  默认就是package_name, 没特殊需求不要写
---@field map_type number  具体看 https://confluence.xindong.com/pages/viewpage.action?pageId=83012558
---@field auto_ensure boolean 是否顺便调用"确保package已被创建"的api, 正常是要填true的, 因为你不知道是不是第一次调用   default: false
---@field with_mob boolean 是否自动enture mob格式后缀的package
---@field request_id string 请求的id编号，通知发布的进度时会指出进度对应的request_id
---@field tag string  要求设置为哪个tag, 如果为nil, 则是根据数据库map_env_info.auto_publish来判断
---@field need_pak boolean 默认为undefined, 意义由服务器决定(package_type in [3,4,9,10,几个特殊二进制]时视为true, 其他时候视为false)
---@field encrypt number   默认为0
---@field api_version number 默认为None, 这会让Publisher认为你选的是最新的api_version, 以后要求必填

local progress_funcs = {}
local progress_funcs_one_time = {}

sce.map_publisher.on_process_package_progress_notify = function(request_id, text)
    log_file.info('on_process_package_progress_notify:', request_id, text)
    if progress_funcs[request_id] then
        progress_funcs[request_id](request_id, text)
    end
    if progress_funcs_one_time[request_id] then
        progress_funcs_one_time[request_id](request_id, text)
        progress_funcs_one_time[request_id] = nil
    end
end

local ensure_package = function(params)
    local out_stream = sce.httplib.create_stream()
    --local url = fmt("http://%s:%s/api/map/update-map-env-info", params.host, params.port)
    local url = base.calc_http_server_address('publisher', 9000) .. '/api/map/update-map-env-info'
    -- url = 'http://127.0.0.1:9000/api/map/update-map-env-info'
    log_file.info(("确保package已被创建 url: %s"):format(url))

    local to_ensure_list = {params.package_name}
    -- 没有mob了
    -- if params.with_mob then
    --     table.insert(to_ensure_list, params.package_name..'_mob')
    -- end

    for _, name in ipairs(to_ensure_list) do
        local code, status = coroutine.call(account.http_request_with_token, sce.httplib.create(), {
            url = url,
            method = 'post',
            json = {
                mapName = name,
                env = 'test',
                path = params.path,
                autoPublish = 1, -- todo
                encrypt = params.encrypt or 1,
                patch = 1,
                alias = params.alias,
                status = 0,
                map_type = params.map_type,
                token = params.token,
                project_id = params.project_id,  -- 仅在上传资源时有效, 用来判定协作者是否有权限修改项目资源
                -- need_pak = params.need_pak  -- 这一列废掉了，之后允许在项目里放个variation.json描述各variation的情况如是否要pak，不放的话由服务端的默认值决定
            },
            --input = {mapName="123"},
            output = out_stream,
        })

        if code ~= 0 or status ~= 200 then
            local err_msg = fmt('更新env_info失败. code[%s] status[%s] out_stream[%s]', code, status, out_stream:read())
            log.error(err_msg)
            return {code = 1, msg = err_msg}
        end

        local text = out_stream:read()
        local ensure_result = json.decode(text)
        if ensure_result.result ~= 0 and ensure_result.result ~= true then
            local err_msg = fmt("更新env_info失败, result: %s", text)
            log.error(err_msg)
            return {code = 1, msg = err_msg}
        end
        log_file.info(('已确保package[%s]被创建, text: %s'):format(name, text))
    end
    return {code = 0}
end

---@param params upload_package_params
local function upload_map(params, auto_ensure, progress_func, progress_func_one_time)
    if not params.author then
        local user_name = account.latest_login_info.user_name
        if type(account.latest_login_info.login_way == 999) then
            user_name = '游客'
        end
        params.author = fmt('%s(%s)', user_name, account.latest_login_info.user_id)
    end
    params.email = params.email or '邮箱没填'
    params.comment = params.comment or '上传者没填'
    params.upload_data = params.upload_data or {}
    params.map_type = params.map_type or (params.upload_data and params.upload_data.packet_type) or 0
    params.path = params.path or 'Res/maps'
    params.alias = params.alias or params.package_name
    params.request_id = params.request_id or 'request_id没填'
    params.encrypt = params.encrypt or 1
    params.api_version = params.api_version or 0
    params.tag_api_version = params.tag_api_version or 0 --默认apiversion都传0


    if params.package_name == "server_common" then
        params.encrypt = 0
    end
    if argv.has("commit_message") then
        params.comment = argv.get("commit_message")
    end
    progress_funcs[params.request_id] = progress_func
    progress_funcs_one_time[params.request_id] = progress_func_one_time
    if params.zip_path and params.folder or not params.zip_path and not params.folder then
        throw(fmt('zip_path和folder应当二选一, 现在: zip_path[%s] folder[%s]', params.zip_path, params.folder))
    end

    if params.folder then
        if not path(params.folder):is_absolute() then
            throw(fmt('params.folder[%s] 应该是绝对路径', params.folder))
        end
        params.zip_path = params.folder..os.date('%Y%m%d_%H%M%S', os.time())..(compress_use_7z and '.7z' or '.zip')
        log_file.info(('压缩package[%s] -> [%s] 开始'):format(params.folder, params.zip_path))

        local code
        if compress_use_7z then
            code = co_io_zip_file({input=params.folder, output=params.zip_path, progress=function () end, use_7z=compress_use_7z})
        else
            code = co_io_zip_file(params.folder, params.zip_path, function()  end)  -- 兼容
        end
        if code ~= 0 then
            throw(fmt('压缩失败[%s] -> [%s], code[%s]', params.folder, params.zip_path, code))
        end
    end

    if type(params.upload_data) == 'table' then
        params.upload_data = json.encode(params.upload_data)
    end


    log_file.info(('上传package开始, package_name[%s], zip_path[%s]'):format(params.package_name, params.zip_path))
    local out_stream = sce.httplib.create_stream()

    coroutine.sleep_one_frame()
    -- 10s太长了, 中间可能存在耗时操作, 造成上传失败
    coroutine.sleep(100)  -- 等3秒, 不然Entrance可能没有重连成功
    coroutine.sleep_one_frame()

    local token_promise = coroutine.promise()
    --sce.map_publisher.apply_upload_token(params.package_name, {
    --    ok = function(token, host, port)
    --        token_promise:set_result({token, host, port})
    --    end,
    --    error = function(code, reason)
    --        token_promise:set_error(fmt('apply_upload_token failed. code[%s] reason[%s]', code, reason))
    --    end,
    --    timeout = function()
    --        token_promise:set_error('apply_upload_token timeout')
    --    end
    --})
    --
    --local token, host, port = table.unpack(token_promise:co_result())

    --params.token = token
    --params.host = host
    --params.port = port
    if params.auto_ensure or auto_ensure then
        local result = ensure_package(params)
        if result.code ~= 0 then
            return result
        end
    end

    -- host, port = '127.0.0.1', 9000
    --local url = fmt("http://%s:%s/api/map/upload-map", host, port)
    local url = base.calc_http_server_address('publisher', 9000)
    url = url..'/api/map/upload-map'
    -- url = 'http://127.0.0.1:9000/api/map/upload-map'
    log_file.info(('上传package url: %s'):format(url))

    local code, status = coroutine.call(account.http_request_with_token, sce.httplib.create(), {
        url = url,
        method = 'post',
        input = {
            mapName = params.package_name,
            branch = 'master',
            author = params.author,
            comment = params.comment,
            email = params.email,
            request_id = params.request_id,
            upload_data = params.upload_data,
            tag = params.tag,
            api_version = params.api_version,
            tag_api_version=params.tag_api_version,
            project_id = params.project_id,  -- 仅在上传资源时有效, 用来判定协作者是否有权限修改项目资源
            [params.package_name] = {
                file = params.zip_path,
            }
        },
        output = out_stream,
    })

    if code ~= 0 or status ~= 200 then
        local err_msg = fmt('上传依赖库失败. code[%s] status[%s] out_stream[%s]', code, status, out_stream:read())
        log.error(err_msg)
        return {code = 3, msg = err_msg}
    end

    local text = out_stream:read()
    local j = json.decode(text)
    if j.result ~= true then
        local err_msg = fmt('上传依赖库失败. %s',  json.encode(j.data))
        log.error(err_msg)
        return {code = 3, msg = err_msg}
    end
    log_file.info(('上传package结束, text: %s'):format(text))
    return {code = 0}
end


---@param params upload_package_params
local function upload_ref(params, auto_ensure, progress_func)
    if not params.author then
        local user_name = account.latest_login_info.user_name
        if type(account.latest_login_info.login_way == 999) then
            user_name = '游客'
        end
        params.author = fmt('%s(%s)', user_name, account.latest_login_info.user_id)
    end
    params.map_type = params.map_type or (params.upload_data and params.upload_data.packet_type) or 0
    params.request_id = params.request_id or 'request_id没填'

    progress_funcs[params.request_id] = progress_func
    if params.zip_path and params.folder or not params.zip_path and not params.folder then
        throw(fmt('zip_path和folder应当二选一, 现在: zip_path[%s] folder[%s]', params.zip_path, params.folder))
    end

    -- params.folder = xxx/User/SCECheckpoint/upload_ref/test_fabu_0706_20231109_144353/test_fabu_0706
    if params.folder then
        if not path(params.folder):is_absolute() then
            throw(fmt('params.folder[%s] 应该是绝对路径', params.folder))
        end
        params.zip_path = string.format("%s_ref_%s.%s", params.folder, os.date("%Y%m%d_%H%M%S", os.time()), (compress_use_7z and '7z' or 'zip'))
        log_file.info(('压缩package[%s] -> [%s] 开始'):format(params.folder, params.zip_path))

        local code
        local ref_folder = params.folder .. "/ref"
        if compress_use_7z then
            code = co_io_zip_file({input=ref_folder, output=params.zip_path, progress=function () end, use_7z=compress_use_7z})
        else
            code = co_io_zip_file(ref_folder, params.zip_path, function()  end)  -- 兼容
        end
        if code ~= 0 then
            throw(fmt('压缩失败[%s] -> [%s], code[%s]', params.folder, params.zip_path, code))
        end
    end

    log_file.info(('上传package开始, package_name[%s], zip_path[%s]'):format(params.package_name, params.zip_path))
    local out_stream = sce.httplib.create_stream()

    coroutine.sleep_one_frame()
    -- 10s太长了, 中间可能存在耗时操作, 造成上传失败
    coroutine.sleep(100)  -- 等3秒, 不然Entrance可能没有重连成功
    coroutine.sleep_one_frame()

    -- local token_promise = coroutine.promise()
    -- sce.map_publisher.apply_upload_token(params.package_name, {
    --     ok = function(token, host, port)
    --         token_promise:set_result({token, host, port})
    --     end,
    --     error = function(code, reason)
    --         token_promise:set_error(fmt('apply_upload_token failed. code[%s] reason[%s]', code, reason))
    --     end,
    --     timeout = function()
    --         token_promise:set_error('apply_upload_token timeout')
    --     end
    -- })

    -- local token, host, port = table.unpack(token_promise:co_result())
    -- -- local token, host, port = nil, "127.0.0.1", 9000
    -- params.token = token
    -- params.host = host
    -- params.port = port
    if params.auto_ensure or auto_ensure then
        local result = ensure_package(params)
        if result.code ~= 0 then
            return result
        end
    end

    local url = base.calc_http_server_address('publisher', 9000) .. '/api/map/upload-ref'
    -- url = 'http://127.0.0.1:9000/api/map/upload-ref'
    log_file.info(('upload_ref, url: %s'):format(url))

    local code, status = coroutine.call(account.http_request_with_token, sce.httplib.create(), {
        url = url,
        method = 'post',
        input = {
            mapName = params.package_name,
            author = params.author,
            request_id = params.request_id,
            -- token = token,
            [params.package_name] = {
                file = params.zip_path,
            }
        },
        output = out_stream,
    })

    if code ~= 0 or status ~= 200 then
        local err_msg = fmt('上传依赖库失败. code[%s] status[%s] out_stream[%s]', code, status, out_stream:read())
        log.error(err_msg)
        return {code = 3, msg = err_msg}
    end

    local text = out_stream:read()
    log_file.info(("text:[%s]").format(text))
    local j = json.decode(text)
    if j.result ~= true then
        local err_msg = fmt('上传依赖库失败. %s',  json.encode(j))
        log.error(err_msg)
        return {code = 3, msg = err_msg}
    end
    log_file.info(('上传package结束, text: %s'):format(text))
    return {code = 0}
end

return {
    ensure_package = ensure_package,
    upload_map = upload_map,
    upload_ref = upload_ref,
}
