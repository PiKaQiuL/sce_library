---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by xindong.
--- DateTime: 2021/9/29 16:22
---
local path                     = require 'base.path'
local try_wrap                 = require 'base.try'.try_wrap
local to_exception             = require 'base.exception'.to_exception
local throw                    = require 'base.exception'.throw
local platform                 = require 'base.platform'
local root_path                = path(io.get_root_dir())
local version_path             = root_path / 'Update' / _G.update_subpath
local local_version            = require 'update.core.local_version'
local version_path             = root_path / 'Update' / _G.update_subpath
local global_client_suffix     = local_version.global_client_suffix
local co                       = require 'base.co'
local create_request           = require 'base.request'
local request                  = create_request('updater')
local env                      = require 'update.core.env'
local argv                     = require 'base.argv'
local map_path                 = require 'update.core.map_path'

--local update            = require 'update.init'
local confirm                  = require 'base.confirm'
local path                     = require 'base.path'
local account                  = require 'base.account'
local reload                   = require 'reload'
local json                     = require 'json'
--local update            = require 'update.init'
local DefaultProgressBind      = require 'base.progress'.DefaultProgressBind
local replace_url_list         = require 'update.core.replace_update_url'
local UpdateTask               = require 'update.update_task'
local lobby                    = require 'base.lobby'
local calc_http_server_address = base.calc_http_server_address

local io_add_resource_path     = io.add_resource_path
local io_remove                = io.remove
local io_rename                = io.rename
local io_unzip_file            = io.unzip_file
local io_serialize             = io.serialize
local io_exist_dir             = io.exist_dir
local io_exist_file            = io.exist_file
local common_stat_sender       = common.stat_sender
local common_get_binary_version = common.get_binary_version
local math_floor                = math.floor
local lua_state_name            = __lua_state_name
local store_value               = require 'base.store_value'
local util                      = require 'base.util'

local editor_version_manager   = require "update.core.api_version_config".editor_version_manager
local api_pak_version_manager  = require 'update.core.local_api_pak_version'
local map_pak_version_manager  = require 'update.core.local_map_pak_version'
local lua_state_name           = __lua_state_name
local tostring = tostring
local table_insert = table.insert

require 'base.ip'
local get_http_env = base.get_http_env

local game_tag = argv.get('tag')
if game_tag == '' then
    game_tag = nil
end

local function call_http(params, timeout)
    local http_request_wrapper = co.wrap(sce.httplib.request)
    timeout = timeout or params.timeout
    local pro = base.as_promise(function()
        return table.pack(http_request_wrapper(params))
    end)
    local code, status = table.unpack(pro:co_result(timeout))
    if code ~= 0 or status ~= 200 then
        error(('request [%s] failed. code[%d] status[%d]'):format(params.url, code, status))
    end

    local output = params.output
    if output then
        local buf = output:read()
        local j = json.decode(buf)
        if j.result ~= 0 then
            error(('request [%s] failed. result[%s]'):format(params.url, j.result))
        end

        return j
    end
end

---@class DoUpdateReturn
---@field cancel fun
---@field finish_promise promise

---@class DoUpdateParams: get_update_download_info_param
---@field status_callback fun(status: string)
---@field progress_bind ProgressBind
---@field on_begin fun   -- 需要外界注册
---@field should_download_server boolean = false
---@field forbidden_check_binary boolean = true
---@field to_download_list table   -- 如果提前传入了这个值, 那么就直接使用该值, 而不再走http去UpdaterServer里查询了
---@field total_download_size number  -- 配合to_download_list使用

---@class DownloadManager
---@field request_deque DoUpdateParams[]
---@field last_http_base string
---@field current_task UpdateTask|nil
---@field update_folder_root path
---@field cache_folder_path path
---@field cache_server_folder_path path
local DownloadManager = class 'download_manager'
DownloadManager.instance = nil ---@type DownloadManager
function DownloadManager:ctor()
    self.request_deque = base.event_queue()
    self.last_http_base = nil
    self.current_task = nil
    DownloadManager.instance = self

    coroutine.async(function()
        self:_process()
    end)
end

function DownloadManager:http_address()
    -- host, port没看到用的
    return calc_http_server_address('updater', 9002) .. '/api/map/'
    --[[
    coroutine.sleep_one_frame()  -- 等一帧再调用, 否则可能会遇到之前逻辑耗时过久导致定时器不准, 提前抛出超时异常
    local result, host, port = co.call(request.http_address)
    log.info(('http_address response: result[%s] host[%s], port[%s]'):format(result, host, port))
    if result ~= 0 then
        error (('http_address failed. response result[%s]'):format(result))
    end
    local http_base = ('http://%s:%d/api/map/'):format(host, port)
    self.last_http_base = http_base
    return http_base, host, port
    --]]
end

---@param do_update_params DoUpdateParams
---@return UpdateTask
function DownloadManager:do_update(do_update_params)
    if do_update_params.progress_bind then
        do_update_params.progress_bind:reset() 
    end
    local start_time = os.time()
    local guest_id = account.get_guest_id()
    -- 通过guest_id, start_time以及1-100的随机数来确定一个update_task
    local session_id = tostring(math.abs(common.string_hash(guest_id .. start_time .. tostring(math.random(0, 100)))))
    do_update_params.reason = do_update_params.reason or 'unknown'
    do_update_params.session_id = session_id
    common_stat_sender('update_start_bstat', {
        guest_id = guest_id,
        reason = do_update_params.reason,
        game = do_update_params.game or argv.get('game'), -- 如果没有这个参数的话，会返回空字符串
        session_id = do_update_params.session_id,
        total_size = do_update_params.total_download_size
    })
    log.info(('do_update start, reason[%s]'):format(do_update_params.reason))
    local task = UpdateTask.new(do_update_params)
    self.request_deque:push(task)

    task.finish_promise:get(nil, function()
        local cost = os.time() - start_time
        local stat_args = {
            guest_id = account.get_guest_id(),
            session_id = do_update_params.session_id,
            reason = do_update_params.reason,
            game = do_update_params.game or argv.get('game'), -- 如果没有这个参数的话，会返回空字符串
            status = task.status,
            cost = cost,
            speed_sd = task.standard_deviation,
            detail = tostring(#task.to_download_list) -- json.encode(task.to_download_list)
        }
        if task.request.progress_bind then
            stat_args.now_downloaded = task.request.progress_bind._now_downloaded
            stat_args.total_size = task.request.progress_bind._total_size
            stat_args.installed_count = task.request.progress_bind._installed_count
            stat_args.to_install_count = task.request.progress_bind._to_install_count -- 指总共要装多少包，不是还有多少包要装
        else
            log.info('task.progress_bind unexpected empty')
        end


        if _G.IP:find('master') then --只在内部测试
            if stat_args.to_install_count~=nil  and stat_args.to_install_count~=0  and (stat_args.installed_count == nil or stat_args.installed_count == 0) then
                log.error("发送消息错误 已经安装的包数量过少", base.json.encode(stat_args),session_id);
            end
        end
        


        common_stat_sender('update_end_bstat', stat_args)

        --- 'waiting'|'pending'|'aborted'|'success'|'cancelled'
        if task.status == 'success' then
            log.info(('do_update success, reason[%s], cost[%s]'):format(do_update_params.reason, cost))
        else
            common_stat_sender('update_error', {
                session_id = do_update_params.session_id,
                reason = do_update_params.reason,
                game = argv.get('game'), -- 如果没有这个参数的话，会返回空字符串
                status = task.status,
                cost = cost,
                detail = tostring(#task.to_download_list) -- json.encode(task.to_download_list)
            })
            log.info(('do_update failed, session_id[%s], reason[%s], status[%s], cost[%s]'):format(do_update_params.session_id, do_update_params.reason, task.status, cost))
        end

        local need_update_shadercache = false
        local pak_list = { script = 1, startup = 2, xdeditor = 3, refconfig = 4, appui = 5, engineres = 6, ui = 7, fonts = 8 }
        local pak_reload_list = {}

        for i = 1, #(task.to_download_list) do
            if pak_list[task.to_download_list[i].name] ~= nil then
                pak_reload_list[task.to_download_list[i].name] = true
            elseif string.find(task.to_download_list[i].name, 'shadercache') ~= nil then
                need_update_shadercache = true
            end
        end

        if lua_state_name == 'StateEditor' then
            for i = 1, #(api_pak_version_manager.changed_pak_list) do
                if pak_list[api_pak_version_manager.changed_pak_list[i]] ~= nil then
                    pak_reload_list[api_pak_version_manager.changed_pak_list[i]] = true
                elseif string.find(api_pak_version_manager.changed_pak_list[i], 'shadercache') ~= nil then
                    need_update_shadercache = true
                end
            end
        elseif lua_state_name == 'StateApplication' then
            for i = 1, #(map_pak_version_manager.changed_pak_list) do
                if pak_list[map_pak_version_manager.changed_pak_list[i]] ~= nil then
                    pak_reload_list[map_pak_version_manager.changed_pak_list[i]] = true
                elseif string.find(map_pak_version_manager.changed_pak_list[i], 'shadercache') ~= nil then
                    need_update_shadercache = true
                end
            end
        end
        map_pak_version_manager.changed_pak_list = {} -- 
        api_pak_version_manager.changed_pak_list = {} -- 清空一下
        
        -- 更新完毕，重新加载shadercache和paks
        if common.reload_pak then
            for name, _ in pairs(pak_reload_list) do
                log.info("重新加载部分paks", name)
                common.reload_pak(name)
            end
        elseif common.load_shadercache_and_paks then
            -- to delete
            common.load_shadercache_and_paks()
        end

        if need_update_shadercache and common.reload_shadercache then
            common.reload_shadercache()
        end
    end)

    return task
end

function DownloadManager:_process()
    while true do
        local task, err = self.request_deque:co_pop() ---@type UpdateTask
        assert(task ~= nil and err == nil) -- 不应该有err的时候
        try {
            function()
                self:_process_one(task) -- 这个函数永不抛异常
            end,
            catch = function(e)
                log.error(e)
            end
        }
    end
end

function DownloadManager:process_updated_binary()
    if not platform.is_wx() and not platform.is_qq() and not (platform.is_web() and (_G.IP == 'e.create-easy.cn' or _G.IP == 'p.create-easy.cn')) then
        if binary_result then
            if platform.is_win() then
                common.send_user_stat('binary_update', 'win')
                local dir = common.get_app_dir()
                local launcher = dir .. argv.get('launcher')
                local cmdline = common.get_full_cmdline()
                log.info(('common.open_url("%s", "%s")'):format(launcher, cmdline))
                log.info('客户端已更新，请重启编辑器(即将弹框)')
                local EMessageBox
                if lua_state_name == 'StateEditor' then
                    EMessageBox = ImportSCEContext():GetEMessageBox()
                    EMessageBox:set_size(300, 160)
                    EMessageBox:begin('客户端已更新，请重启编辑器;;重启编辑器')
                else
                    confirm.message(base.i18n.get_text('客户端已更新，请重启客户端'))
                end
                common.open_url(launcher, cmdline)
                log.info("common.force_exit()")
                common.force_exit()
            end
        end
        if need_reload and not platform.is_wx() and not platform.is_qq() then
            reload.run({ stop = stop }, _G.update_subpath)
            return
        else
            log.info('不需要更新启动页')
            base.game:send_broadcast('启动页更新完毕')
        end
    end
end


---@param params get_update_download_info_param
---@return update_info_row[]
function DownloadManager:update_version_info(params)
    local update_request_array = {} ---@type string[]
    local update_list = params.update_list
    for _, v in ipairs(update_list) do
        if type(v) == 'table' then
            v = json.encode(v)
        end

        table_insert(update_request_array, v)
    end

    local list_str = table.concat(update_request_array, ';')

    if not self.last_http_base then
        self.last_http_base = self:http_address()
    end

    params.suffix = params.suffix or global_client_suffix

    local url = self.last_http_base .. 'update-info'
    log.info(("request url[%s] with maps[%s], default_part[%s], suffix[%s]"):format(url, list_str, params.default_part, params.suffix))
    local editor_api_version = 0;
    if lua_state_name == 'StateEditor' then -- 读取编辑器的API版本号 游戏不需要
        local api_version_cfg, _is_ask = editor_version_manager:get();
        editor_api_version = api_version_cfg.api_version;
    end
    local input = {
        list = list_str,
        aim_version = params.aim_version and json.encode(params.aim_version),
        sample = 0,
        default_part = params.default_part,
        suffix = params.suffix,
        tag = game_tag,
        is_editor = lua_state_name == 'StateEditor' and 1 or nil,
        version = 2,
        api_version = editor_api_version
    }
    local need_add_review_arg = false
    if platform.is_ios() and store_value.get_store_bool('ios_add_review_args') == false and lua_state_name == 'StateApplication' then
        need_add_review_arg = true
        local review_version = {
            name = platform.binary():lower(),
            version = math_floor(common_get_binary_version())
        }
        input['review_version'] = json.encode(review_version)
    end
    log.info("update-info2 input", json.encode(input));
    log.info(("luaState[%s] editor_api_version[%s]"):format(lua_state_name, tostring(editor_api_version)))
    if argv.has("actual_binary_api") then
        log.info("实际启动的二进制版本为", argv.get("actual_binary_api"))
    end
    if params.update_info_start then
        params.update_info_start()
    end
    local output = sce.httplib.create_stream()
    local code, status_code = co.call(sce.httplib.request, {
        method = 'post',
        url = url,
        input = input,
        output = output,
    })
    if params.update_info_end then
        params.update_info_end()
    end
    if code ~= 0 or status_code ~= 200 then
        throw(fmt("update_version_info failed. code[%s], status_code[%s]", code, status_code))
    end

    log.info("code 200")

    local content = output:read()
    local readline = (function()
        local begin = 1
        return function()
            local index = content:find('\r\n', begin)
            if index then
                local ret = content:sub(begin, index)
                begin = index + 2
                return ret
            else
                local ret = nil
                if begin ~= #content then
                    ret = content:sub(begin, #content)
                end
                begin = #content
                return ret
            end
        end
    end)()

    log.info("read content finish")

    local line_version = readline()
    assert(line_version)
    local line_buffer_type = readline()
    assert(line_buffer_type)

    local line_pac
    if need_add_review_arg then
        local review_arg_data = readline()
        log.info("ios平台额外添加的参数", review_arg_data)
        store_value.set_store_value('ios_add_review_args', true)
        if util.is_prefix(review_arg_data, 'review_arg:') then
            local json_data = review_arg_data:sub(12)
            local info, error_info = common.json_decode(json_data)
            if info then
                local mess = info[platform.binary():lower()]
                if type(mess) == "string" and #mess > 0 then
                    local datas, error_info = common.json_decode(mess)
                    if datas then
                        for key, value in pairs(datas) do
                            argv.add(key, value)
                        end
                    else
                        log.warn('解析 review_arg二段 失败' .. tostring(error_info))
                    end
                end
            else
                log.warn('解析 review_arg 失败' .. tostring(error_info))
            end
            line_pac = readline() -- 服务器更新了 正常读第四行 
        else
            line_pac = review_arg_data -- 服务器没更新 第三行就是info
        end
    else
        line_pac = readline() -- 正常读 第三行
    end
    local info_list = {} ---@type update_info_row[]

   
    local env = get_http_env()
    if env == 'master' and lua_state_name ~= 'StateEditor' then
        log.info("update-info2\n", line_pac)
    end
    local ref_items = {}
    local_version:load(version_path);
    log.info("local_version:load() finish")
    api_pak_version_manager:load();
    log.info("api_pak_version_manager:load() finish")
    map_pak_version_manager:load();
    local suc, info = pcall(json.decode, line_pac);
    if suc then
        ref_items = info["ref_items"];
        local items = info["items"];
        -- 修正服务器发到客户端的一些数据 放到最前面
        for index, item in ipairs(items) do
            if lua_state_name == 'StateEditor' and item['name']:find('shadercache_') and editor_api_version >= 3 then -- ClearLove 服务器还没改暂时这么强判 之后删掉
                item['same_api_version'] = 1
                item['api_version'] = editor_api_version
            end

            if item['api_version'] == nil then
                item['api_version'] = -1;
            end
            if item['packet_type'] == 14 then --第三方库统一用 api_version = -2
                item['api_version'] = -2
            end
            if item['api_version'] ~= -1 then
                api_pak_version_manager:set_pak_multi(item.name)
            end
            if item.variation then
                if item.variation == "windows_game" then
                    item.suffix = "client"
                elseif item.variation == "mob" then
                    item.suffix = "_mob"
                else
                    item.suffix = item.variation;
                end
            else
                item.suffix = 'client';
            end

        end

        local map_pak_name = {};                     -- 包名，版本号 ->对应的地图名列表
        for map_name, itemList in pairs(ref_items) do --先把地图用到的包名字存起来
            for index, item in ipairs(itemList) do
                if map_pak_name[item['name'] .. ':' .. item['version']] == nil then
                    map_pak_name[item['name'] .. ':' .. item['version']] = {};
                end
                table_insert(map_pak_name[item['name'] .. ':' .. item['version']], map_name);                                   -- 暂存哪些包是游戏用上的包 (包名+版本号) 映射到地图名
                if local_version:has(item['name'], item['version']) and api_pak_version_manager:is_multi_api(item['name']) then        -- 记录单版本的游戏用到的包 如果这个包已经在本地有 就保存
                    map_pak_version_manager:set(map_name, item['name'], item['version'])
                end
            end
        end
        
        for index, item in ipairs(items) do
             -- 对于StateApp的API版本是 0 且只需要几个特定的包  appui gameui global_default script
            if item['api_version'] == 0 and lua_state_name == "StateApplication" and item['same_api_version'] == 1
                and map_pak_version_manager:is_state_application_need_pak(item['name'])
            then
                local target = item['name'] .. ':' .. item['version']
                if map_pak_name[target] == nil then
                    map_pak_name[target] = {}
                end
                table_insert(map_pak_name[target], "#StateApplication")
                if local_version:has(item['name'], item['version']) then
                    map_pak_version_manager:set("#StateApplication", item['name'], item['version'])
                end
            end

            if item['api_version'] ~= -1 then
                log.info(("多API包 %s %s"):format(item['name'], json.encode(item)))
            end

            if item['api_version'] ~= -1 and item['variation'] ~= 'server' and item['name'] ~= 'wineditor' then
                -- 多版本的API包 把输出的路径 改掉成 _multi_api/ 旧路径 /包名/版本号/
                local oldPath = item['path'];
                item['origin_path'] = oldPath -- 记录原始路径
                local prefix = string.gsub(oldPath, "Res", "Res/_m") .. '/' .. item['name']
                api_pak_version_manager:set_multi_pak_path(item['name'], prefix);
                local newPath = prefix .. '/' .. tostring(item['version'])
                newPath = string.gsub(newPath, '//', '/')
                item['path'] = newPath;
            end

            if item['variation'] ~= 'server' then                                      --服务器的包当做没有
                if item['api_version'] ~= -1 or params.request_game_info == true then          --除非是请求游戏依赖包 否则不存非多API的数据 没什么价值
                    item['belong_map'] = map_pak_name[item['name'] .. ':' .. item['version']]; -- 使用之前的映射
                end
                table_insert(info_list, item);
                if local_version:has(item['name'], item['version']) then -- local_version中已经存在这个包时，更新数据 item['api_version']
                    if lua_state_name == 'StateEditor' then              -- 编辑器模式下修改api_pak_version
                        if item['api_version'] < 0 then                 -- 非多API和第三方库直接保存
                            api_pak_version_manager:set(item['api_version'], item['name'], item['version'])
                        elseif item['same_api_version'] ~= nil then      --多API判断当前是否是用自己的这个版本的
                            api_pak_version_manager:set(editor_api_version, item['name'], item['version'])
                        end
                    else --游戏模式下 直接根据数据里api_version保存 其实只需要知道是不是多API的就够了 不需要知道准确的API版本
                        api_pak_version_manager:set(item['api_version'], item['name'], item['version']);
                    end
                end
            end
        end
    else
        log.error("update_version_info json.decode failed");
    end
    api_pak_version_manager:save();
    map_pak_version_manager:save();
    return info_list, ref_items
end

local function need_query_patch(info)
    if lua_state_name == 'StateEditor' then
        if argv.has('actual_binary_api') then
            local actual_binary_api = tonumber(argv.get('actual_binary_api'))
            if type(actual_binary_api) == "number" and actual_binary_api < 4 then
                return false
            end
        end
        local editor_api_version = 0;
        local api_version_cfg, _is_ask = editor_version_manager:get();
        editor_api_version = api_version_cfg.api_version;
        if editor_api_version < 4 then --之前的二进制不请求补丁
            return false
        end
    end
    if info.packet_type == 10 then
        return false
    end
    return true
end

---@param info_list update_info_row[]
---@return number, update_info_row[]
function DownloadManager:get_update_download_info(info_list)
    local to_calc_patch_list = {}
    local to_download_list = {} ---@type update_info_row[]
    local to_query_dict = {} ---@type table<string, update_info_row>

    local need_query_count = 0
    local binary_name = platform.binary():lower()
    for _, info in ipairs(info_list) do
        local version, suffix = local_version:get(info.name)
        local need_download = true
        api_pak_version_manager:load();
        local is_multi_api = api_pak_version_manager:is_multi_api(info.name)
        if info.name ~= binary_name then                                             -- 二进制走自己的判断
            if is_multi_api then
                version = local_version:get_nearest_version(info.name, info.version) -- 多API包最大小于info版本号的版本号,用于打补丁
                if version > info.version then                                       --这种情况不能打补丁
                    version = 0
                end
                if local_version:has(info.name, info.version) then
                    need_download = false -- 多API包 如果已经有了当前版本 就不下
                end
            else
                if version > info.version and local_version:is_embedded_package(info.name) then -- 非多API包且有内嵌包 不下载比自己版本低的
                    log.info("存在内嵌包不下载低版本的")
                    log.info(json.encode(info))
                    need_download = false
                end
            end
        end
        local need_download_binary = false -- 是否需要更新二进制
        if lua_state_name == 'StateEditor' then
            need_download_binary = (not (binary_name == info.name and version == info.version)) -- 编辑器会更新成低版本的二进制包
        else
            need_download_binary = (not (binary_name == info.name and version > info.version)) -- 游戏二进制不下载比自己版本低的
        end

        if (version ~= info.version and version < 1000000) and need_download_binary and need_download then
            local name = info.name
            if version ~= 0 and not info.is_server and info.packet_type ~= 1003 and need_query_patch(info) then
                local newItem = {
                    name = name,
                    src = version,
                    dest = info.version,
                    variation = info.variation
                }
                table_insert(to_calc_patch_list, newItem)
                need_query_count = need_query_count + 1
                to_query_dict[info.name .. '-' .. tostring(info.version)] = info -- 加上info自己的包版本号
            end
            info.old_version = version
            log.info(("AAAAA info.name[%s], binary_name[%s], version[%s(%s)], info.version[%s(%s)], info.is_server[%s], suffix[%s:%s]"):format(info.name, binary_name, version, type(version), info.version, type(info.version), info.is_server, suffix, info.suffix))
            table_insert(to_download_list, info)
        end
    end

    if need_query_count > 0 then
        local request_json = {
            list = to_calc_patch_list
        }

        local output = sce.httplib.create_stream()
        local input = sce.httplib.create_stream()
        input:write(json.encode(request_json))
        input:feed_eof()
        log.info(('------------ request patch-info begin. count: %d -----------'):format(need_query_count))
        local http_res = call_http({
            json = request_json,
            url = self.last_http_base .. 'patch-info',
            output = output,
            content_type = 'application/json',
            method = 'post',
            input = input,
        }, 20000)

        if http_res.result == 0 then
            for _, patch_info in ipairs(http_res.data) do
                local real_map_name = patch_info['map_name']
                if real_map_name:sub(-4) == '_mob' then
                    real_map_name = real_map_name:sub(1, -5)
                end
                real_map_name = real_map_name:lower()
                local name_version = real_map_name .. '-' .. tostring(patch_info.dest)
                if to_query_dict[name_version] then
                    to_query_dict[name_version].patch_info = patch_info
                else
                    local li = {}
                    for k in pairs(to_query_dict) do
                        table_insert(li, k)
                    end
                    error(fmt('real_map_name[%s] not in to_query_dict[%s]', real_map_name, table.concat(li, ',')))
                end
            end
        else
            log.info(('------------ request patch-info error. result: %d -----------'):format(http_res.result))
        end
    end

    local sum = 0.0
    local to_extract_bytes = 0.0

    for _, v in ipairs(to_download_list) do
        if v.patch_info then
            sum = sum + v.patch_info.size
        else
            sum = sum + v.size
        end
        to_extract_bytes = to_extract_bytes + v.original_size
    end

    return sum, to_download_list, to_extract_bytes
end

---@param task UpdateTask
function DownloadManager:_process_one(task)
    xpcall(function()
        if task.request.on_begin then
            task.request.on_begin()
        end
    end, log.error)

    try {
        function()
            self.current_task = task
            local_version:load(task.update_folder_root)

            log.info(('task[%s] request update list: %s, reason[%s]'):format(task, json.encode(task.request.update_list), task.request.reason))

            if not task.request.to_download_list then
                local final_update_list = self:update_version_info(task.request)
                log.info(('#final_update_list: %s'):format(#final_update_list))

                local to_download_size, to_download_list, to_extract_bytes = self:get_update_download_info(final_update_list)
                task.to_download_list                                      = to_download_list
                task.total_download_size                                   = to_download_size
                task.to_extract_bytes                                      = to_extract_bytes
            else
                task.to_download_list = task.request.to_download_list
                task.total_download_size = task.request.total_download_size
                task.to_extract_bytes = task.request.to_extract_bytes
            end

            assert(task.total_download_size ~= nil)
            task:run()
        end,
        catch = function(e)
            log.error(e)
        end
    }

    self.current_task = nil

    task:_set_finish_promise_result()
end

DownloadManager.new()
return DownloadManager.instance
